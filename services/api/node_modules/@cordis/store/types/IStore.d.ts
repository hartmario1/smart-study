import type { Store } from './Store';
export declare type StoreReturnT<T> = T | Promise<T>;
export declare type StoreSingleEntryCallback<T> = (value: T, key: string) => boolean;
export declare type StoreSortCallback<T> = (firstV: T, secondV: T, firstK: string, secondK: string) => number;
export declare type StoreReduceCallback<V, T> = (acc: V, value: T, key: string) => V;
export declare type StoreMapCallback<V, T> = (value: T, key: string) => V;
export interface IStore<T> {
    get(key: string): StoreReturnT<T | undefined>;
    set(key: string, value: T): StoreReturnT<this>;
    delete(key: string): StoreReturnT<boolean>;
    findKey(cb: StoreSingleEntryCallback<T>): StoreReturnT<string | undefined>;
    find(cb: StoreSingleEntryCallback<T>): StoreReturnT<T | undefined>;
    filter(cb: StoreSingleEntryCallback<T>): StoreReturnT<Store<T>>;
    sort(cb?: StoreSortCallback<T>): StoreReturnT<Store<T>>;
    mSort(cb?: StoreSortCallback<T>): StoreReturnT<Store<T>>;
    map<V = T>(cb: StoreMapCallback<V, T>): StoreReturnT<V[]>;
    empty(cb?: StoreSingleEntryCallback<T>): StoreReturnT<number>;
    reduce<V = T>(cb: StoreReduceCallback<V, T>, initial?: V): StoreReturnT<V>;
    [Symbol.iterator]?(): IterableIterator<[string, T]>;
    [Symbol.asyncIterator]?(): AsyncIterator<[string, T]>;
}
//# sourceMappingURL=IStore.d.ts.map