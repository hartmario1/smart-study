"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RedisStore = exports.CordisRedisStoreTypeError = void 0;
const tslib_1 = require("tslib");
const store_1 = require("@cordis/store");
const error_1 = (0, tslib_1.__importDefault)(require("@cordis/error"));
exports.CordisRedisStoreTypeError = (0, error_1.default)(TypeError, {
    noReduceEmptyStore: 'Cannot reduce an empty store without an initial value'
});
class RedisStore {
    constructor(options) {
        this.hash = options.hash;
        this.redis = options.redis;
        this.maxSize = options.maxSize ?? null;
        this.emptyEvery = options.emptyEvery ?? null;
        this.emptyCb = options.emptyCb ?? null;
        this.encode = options.encode ?? (data => data);
        this.decode = options.decode ?? (data => data);
        if (options.entries) {
            for (const [id, presence] of options.entries) {
                void this.set(id, presence);
            }
        }
        if (this.emptyEvery) {
            this.emptyTimer = setInterval(() => void (this.emptyCb ? this.empty(this.emptyCb) : this.empty()), this.emptyEvery);
        }
        else {
            this.emptyTimer = null;
        }
    }
    async *[Symbol.asyncIterator]() {
        const seenKeys = new Set();
        for await (const chunk of this.redis.hscanStream(this.hash)) {
            let isKey = true;
            let currentKey;
            for (const element of chunk) {
                if (seenKeys.has(element)) {
                    continue;
                }
                if (isKey) {
                    seenKeys.add(element);
                    currentKey = element;
                }
                else {
                    yield [currentKey, this.decode(element)];
                }
                isKey = !isKey;
            }
        }
    }
    async get(key) {
        const data = await this.redis.hget(this.hash, key);
        if (!data) {
            return;
        }
        return this.decode(data);
    }
    async set(key, value) {
        const size = await this.redis.hlen(this.hash);
        if (this.maxSize && size >= this.maxSize) {
            await this.empty();
        }
        await this.redis.hset(this.hash, key, this.encode(value));
        return this;
    }
    async delete(key) {
        const count = await this.redis.hdel(this.hash, key);
        return count > 0;
    }
    async findKey(cb) {
        for await (const [key, value] of this) {
            if (cb(value, key)) {
                return key;
            }
        }
    }
    async find(cb) {
        for await (const [key, value] of this) {
            if (cb(value, key)) {
                return value;
            }
        }
    }
    async filter(cb) {
        const store = new store_1.Store();
        for await (const [key, value] of this) {
            if (cb(value, key)) {
                store.set(key, value);
            }
        }
        return store;
    }
    async sort(cb = (x, y) => Number(x > y)) {
        const raw = await this.redis.hgetall(this.hash);
        const entries = Object
            .entries(raw)
            .map(([key, value]) => [
            key,
            this.decode(value)
        ])
            .sort((a, b) => cb(a[1], b[1], a[0], b[0]));
        return new store_1.Store({ entries });
    }
    async mSort(cb = (x, y) => Number(x > y)) {
        const raw = await this.redis.hgetall(this.hash);
        const entries = Object
            .entries(raw)
            .map(([key, value]) => [
            key,
            this.decode(value)
        ])
            .sort((a, b) => cb(a[1], b[1], a[0], b[0]));
        await this.redis.del(this.hash);
        for (const [key, value] of entries) {
            await this.redis.hset(this.hash, key, this.encode(value));
        }
        return new store_1.Store({ entries });
    }
    async map(cb) {
        const output = [];
        for await (const [key, value] of this) {
            output.push(cb(value, key));
        }
        return output;
    }
    async empty(cb) {
        if (!cb) {
            return this.redis.del(this.hash);
        }
        let deletes = 0;
        for await (const [key, value] of this) {
            if (cb(value, key)) {
                await this.redis.hdel(this.hash, key);
                deletes++;
            }
        }
        return deletes;
    }
    async reduce(cb, initial) {
        let accum;
        if (initial != null) {
            accum = initial;
            for await (const [key, value] of this) {
                accum = cb(accum, value, key);
            }
            return accum;
        }
        let first = true;
        for await (const [key, value] of this) {
            if (first) {
                accum = value;
                first = false;
                continue;
            }
            accum = cb(accum, value, key);
        }
        if (first) {
            throw new exports.CordisRedisStoreTypeError('noReduceEmptyStore');
        }
        return accum;
    }
}
exports.RedisStore = RedisStore;
//# sourceMappingURL=index.js.map