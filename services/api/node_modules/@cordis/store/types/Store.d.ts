/// <reference types="node" />
import type { IStore, StoreMapCallback, StoreReduceCallback, StoreSingleEntryCallback, StoreSortCallback } from './IStore';
export declare const CordisStoreTypeError: {
    new (key: "noReduceEmptyStore", ...args: any[]): {
        stack: string;
        code: "noReduceEmptyStore";
        readonly name: string;
        message: string;
    };
    captureStackTrace(targetObject: object, constructorOpt?: Function | undefined): void;
    prepareStackTrace?: ((err: Error, stackTraces: NodeJS.CallSite[]) => any) | undefined;
    stackTraceLimit: number;
};
export interface StoreOptions<T> {
    entries?: ReadonlyArray<readonly [string, T]> | null;
    maxSize?: number | null;
    emptyEvery?: number | null;
    emptyCb?: StoreSingleEntryCallback<T> | null;
}
export declare class Store<T> extends Map<string, T> implements IStore<T> {
    readonly maxSize: number | null;
    readonly emptyEvery: number | null;
    readonly emptyCb: StoreSingleEntryCallback<T> | null;
    readonly emptyTimer: NodeJS.Timer | null;
    constructor(options?: StoreOptions<T>);
    get(key: string): T | undefined;
    set(key: string, value: T): this;
    delete(key: string): boolean;
    findKey(cb: StoreSingleEntryCallback<T>): string | undefined;
    find(cb: StoreSingleEntryCallback<T>): T | undefined;
    filter(cb: StoreSingleEntryCallback<T>): Store<T>;
    sort(cb?: StoreSortCallback<T>): Store<T>;
    mSort(cb?: StoreSortCallback<T>): this;
    map<V = T>(cb: StoreMapCallback<V, T>): V[];
    empty(cb?: StoreSingleEntryCallback<T>): number;
    reduce<V = T>(cb: StoreReduceCallback<V, T>, initial?: V): V;
}
//# sourceMappingURL=Store.d.ts.map