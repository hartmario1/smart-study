"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitField = exports.BitfieldRangeError = void 0;
const tslib_1 = require("tslib");
const error_1 = tslib_1.__importDefault(require("@cordis/error"));
exports.BitfieldRangeError = error_1.default(RangeError, {
    bitfieldInvalid: 'Failed to resolve bits; expected a bigint, string, a Bitfield, or an array of any of the previous'
});
class BitField {
    constructor(flags, bits) {
        this.flags = flags;
        this.bits = this.resolve(bits);
    }
    static makeFlags(flags) {
        return flags.reduce((acc, current, index) => {
            acc[current] = 1n << BigInt(index);
            return acc;
        }, {});
    }
    static resolve(bit, flags) {
        if (typeof bit === 'bigint' && bit >= 0n)
            return bit;
        if (bit instanceof BitField)
            return bit.bits;
        if (typeof bit === 'string') {
            const num = flags[bit];
            if (num)
                return num;
        }
        if (Array.isArray(bit))
            return bit.map(p => this.resolve(p, flags)).reduce((prev, p) => prev | p, 0n);
        throw new exports.BitfieldRangeError('bitfieldInvalid');
    }
    *[Symbol.iterator]() {
        yield* this.toArray();
    }
    toArray() {
        return Object.keys(this.flags).filter(b => this.has(b));
    }
    toJSON() {
        return String(this.bits);
    }
    valueOf() {
        return this.bits;
    }
    freeze() {
        return Object.freeze(this);
    }
    any(bit) {
        return (this.bits & this.resolve(bit)) !== 0n;
    }
    equals(bit) {
        return this.bits === this.resolve(bit);
    }
    has(bit) {
        if (Array.isArray(bit))
            return bit.every(b => this.has(b));
        return (this.bits & this.resolve(bit)) !== 0n;
    }
    missing(bit) {
        if (!Array.isArray(bit))
            bit = new this.constructor(this.flags, bit).toArray();
        return bit.filter(p => !this.has(p));
    }
    add(...bits) {
        let total = 0n;
        for (const bit of bits)
            total |= this.resolve(bit);
        if (Object.isFrozen(this))
            return new this.constructor(this.flags, this.bits | total);
        this.bits |= total;
        return this;
    }
    remove(...bits) {
        let total = 0n;
        for (const bit of bits)
            total |= this.resolve(bit);
        if (Object.isFrozen(this))
            return new this.constructor(this.flags, this.bits & ~total);
        this.bits &= ~total;
        return this;
    }
    resolve(bit) {
        return this.constructor.resolve(bit, this.flags);
    }
    serialize() {
        const serialized = {};
        for (const [flag, bit] of Object.entries(this.flags))
            serialized[flag] = this.has(bit);
        return serialized;
    }
}
exports.BitField = BitField;
//# sourceMappingURL=index.js.map