"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readdirRecursePromise = exports.readdirRecurse = exports.RecursiveDirReadStream = exports.ReadMode = void 0;
const stream_1 = require("stream");
const promises_1 = require("fs/promises");
const path_1 = require("path");
var ReadMode;
(function (ReadMode) {
    ReadMode[ReadMode["file"] = 0] = "file";
    ReadMode[ReadMode["dir"] = 1] = "dir";
    ReadMode[ReadMode["both"] = 2] = "both";
})(ReadMode = exports.ReadMode || (exports.ReadMode = {}));
class RecursiveDirReadStream extends stream_1.Readable {
    constructor(root, options) {
        super({
            objectMode: true,
            encoding: 'utf8',
            highWaterMark: options?.highWaterMark ?? 1e6
        });
        this.root = root;
        this._reading = false;
        this._nodes = [this._explore(root, 1)];
        this.fileExtension = options?.fileExtension ?? null;
        this.readMode = options?.readMode
            ? (typeof options.readMode === 'string' ? ReadMode[options.readMode] : options.readMode)
            : ReadMode.file;
    }
    _onError(e) {
        if (RecursiveDirReadStream.expectedErrors.has(e.code) && !this.destroyed)
            return void this.emit('warn', e);
        return this.destroy(e);
    }
    async _explore(path, depth) {
        let files;
        try {
            files = await promises_1.readdir(path);
        }
        catch (e) {
            this._onError(e);
        }
        return { files, depth, path };
    }
    async _read(batch) {
        if (this._reading)
            return;
        this._reading = true;
        try {
            while (!this.destroyed && batch > 0) {
                if (this._current?.files && this._current.files.length > 0) {
                    const { files = [], depth, path } = this._current;
                    for (const entry of files.splice(0, batch)) {
                        if (this.destroyed)
                            return;
                        const full = path_1.join(path, entry);
                        await promises_1.stat(full)
                            .then(stats => {
                            if (stats.isDirectory()) {
                                this._nodes.push(this._explore(full, depth + 1));
                                if (this.readMode !== ReadMode.file)
                                    this.push(full);
                            }
                            else if (this.readMode !== ReadMode.dir && (!this.fileExtension || entry.endsWith(this.fileExtension))) {
                                this.push(full);
                            }
                        })
                            .catch(e => this._onError(e));
                        batch--;
                    }
                }
                else {
                    const parent = this._nodes.pop();
                    if (!parent) {
                        this.push(null);
                        break;
                    }
                    this._current = await parent;
                    if (this.destroyed)
                        return;
                }
            }
        }
        catch (e) {
            this.destroy(e);
        }
        finally {
            this._reading = false;
        }
    }
}
exports.RecursiveDirReadStream = RecursiveDirReadStream;
RecursiveDirReadStream.expectedErrors = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP']);
const readdirRecurse = (root, options) => new RecursiveDirReadStream(root, options);
exports.readdirRecurse = readdirRecurse;
const readdirRecursePromise = (root, options) => new Promise((resolve, reject) => {
    const files = [];
    exports.readdirRecurse(root, options)
        .on('data', entry => files.push(entry))
        .on('end', () => resolve(files))
        .on('error', error => reject(error));
});
exports.readdirRecursePromise = readdirRecursePromise;
//# sourceMappingURL=index.js.map