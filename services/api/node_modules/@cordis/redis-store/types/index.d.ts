/// <reference types="node" />
import { Store, IStore, StoreOptions, StoreSingleEntryCallback, StoreSortCallback, StoreReduceCallback, StoreMapCallback } from '@cordis/store';
import type { Redis } from 'ioredis';
export declare const CordisRedisStoreTypeError: {
    new (key: "noReduceEmptyStore", ...args: any[]): {
        stack: string;
        code: "noReduceEmptyStore";
        readonly name: string;
        message: string;
    };
    captureStackTrace(targetObject: object, constructorOpt?: Function | undefined): void;
    prepareStackTrace?: ((err: Error, stackTraces: NodeJS.CallSite[]) => any) | undefined;
    stackTraceLimit: number;
};
export declare type EncodeCallback<T> = (value: T) => any;
export declare type DecodeCallback<T> = (value: any) => T;
export interface RedisStoreOptions<T> extends StoreOptions<T> {
    redis: Redis;
    hash: string;
    encode?: (value: T) => any;
    decode?: (value: any) => T;
}
export declare class RedisStore<T> implements IStore<T> {
    [Symbol.asyncIterator](): AsyncGenerator<[string, T], void, unknown>;
    readonly hash: string;
    readonly redis: Redis;
    readonly maxSize: number | null;
    readonly emptyEvery: number | null;
    readonly emptyCb: StoreSingleEntryCallback<T> | null;
    readonly encode: EncodeCallback<T>;
    readonly decode: DecodeCallback<T>;
    readonly emptyTimer: NodeJS.Timer | null;
    constructor(options: RedisStoreOptions<T>);
    get(key: string): Promise<T | undefined>;
    set(key: string, value: T): Promise<this>;
    delete(key: string): Promise<boolean>;
    findKey(cb: StoreSingleEntryCallback<T>): Promise<string | undefined>;
    find(cb: StoreSingleEntryCallback<T>): Promise<T | undefined>;
    filter(cb: StoreSingleEntryCallback<T>): Promise<Store<T>>;
    sort(cb?: StoreSortCallback<T>): Promise<Store<T>>;
    mSort(cb?: StoreSortCallback<T>): Promise<Store<T>>;
    map<V = T>(cb: StoreMapCallback<V, T>): Promise<V[]>;
    empty(cb?: StoreSingleEntryCallback<T>): Promise<number>;
    reduce<V = T>(cb: StoreReduceCallback<V, T>, initial?: V): Promise<V>;
}
//# sourceMappingURL=index.d.ts.map