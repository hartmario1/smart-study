/// <reference types="node" />
export declare const BitfieldRangeError: {
    new (key: "bitfieldInvalid", ...args: any[]): {
        code: "bitfieldInvalid";
        stack: string;
        readonly name: string;
        message: string;
    };
    captureStackTrace(targetObject: object, constructorOpt?: Function | undefined): void;
    prepareStackTrace?: ((err: Error, stackTraces: NodeJS.CallSite[]) => any) | undefined;
    stackTraceLimit: number;
};
export interface UnsafeBitFieldProperties<K> {
    [Symbol.iterator](): Generator<K, void, undefined>;
}
export declare type FrozenBitField<K extends string, T extends BitField<K>> = Readonly<T> & UnsafeBitFieldProperties<K>;
export declare type BitFieldResolvable<T extends string> = T | bigint | BitField<T> | (T | bigint | BitField<T>)[];
export declare class BitField<T extends string> {
    static makeFlags<T extends string>(flags: T[]): Record<T, bigint>;
    static resolve<T extends string>(bit: BitFieldResolvable<T>, flags: Record<T, bigint>): bigint;
    [Symbol.iterator](): Generator<T, void, undefined>;
    flags: Record<T, bigint>;
    bits: bigint;
    ['constructor']: typeof BitField;
    constructor(flags: Record<T, bigint>, bits: BitFieldResolvable<T>);
    toArray(): T[];
    toJSON(): string;
    valueOf(): bigint;
    freeze(): FrozenBitField<T, this>;
    any(bit: BitFieldResolvable<T>): boolean;
    equals(bit: BitFieldResolvable<T>): boolean;
    has(bit: BitFieldResolvable<T>): boolean;
    missing(bit: BitFieldResolvable<T>): (bigint | BitField<T> | T)[];
    add(...bits: BitFieldResolvable<T>[]): BitField<T>;
    remove(...bits: BitFieldResolvable<T>[]): BitField<T>;
    resolve(bit: BitFieldResolvable<T>): bigint;
    serialize(): Record<T, boolean>;
}
//# sourceMappingURL=index.d.ts.map